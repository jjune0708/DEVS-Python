.PN1
.OP
.PL63
.PO10
.MT7
.MB4
.HM2
.FM0
.H1                        Guoqing Zhang       11/7/1987           Page #


                              Algorithm for Deepening



            1. Command:  (DEEP-DEVS Mname M_lst New Class)
                         (DEEP_DEVS Mname M_lst New Class)

       (1)  Mname  --  The instance of a class  which  is  the  subclass  
                       of the DIGRAPH-MODELS.
       (2)  M_lst  --  A  list  of  model  names  which   exist  as  the 
                       children of Mname given as '(name1 name2 ....)
       (3)  New    --  The  new  model name, which will  be  the  father
                       model of all instances in M_lst given as 'new-name
       (4)  Class  --  The class name to which NEW belongs.


                           2. Command Notes

    Any  instance  of a class which is the subclass  of  the  DIGRAPH-
MODELS is eligible for this command.  As shown in Figure 1, all models 
marked with * can be selected for this command.

                             3. Notations

    In the proposed algorithm that follows, the coupling list is a set 
containing triples in the form (S T (a.b)).  Each triple in the set is 
interpreted as : model S sends message to model B via the port 'a'  of 
model S to port 'b' of model T.  

    Five  selection  operators are defined to extract  each  piece  of 
information from a triple defined above.  

                   (1) SOURCE
                   (2) TARGET
                   (3) IN
                   (4) OUT
                  
    For  example, if e = (S T (a.b)) is in the coupling list, we   get  
the following :

                   (1) e.source = S
                   (2) e.target = T
                   (3) e.in     = b
                   (4) e.out    = a






.H1      Deepening Algorithm        Guoqing Zhang   11/7/1987      Page #

    There  is a need to uniquely name input/output ports for  the  new           
model, NEW, otherwise there will be a false coupling configuration  in 
the  resulting model structure.  Figure 2a and Figure 2b show  one  of 
the problems.  The proposed algorithm solved the problem by  assigning 
a single port (input or output) for each coupling to/from any model in 
the M_lst.  For this purpose, two counters, Ncnt-in and Ncnt-out,  and 
one  procedure, PORT&ZHANG are used to generate unique ports for  NEW. 
In  the  following description NEW_OUT_PORT gives  the  unique  output 
port, and NEW_IN_PORT returns the unique input port.



                4. Coupling Lists and Model Structure.


    The command invoked is  (DEEP-DEVS COOR GNAMES NEW CLS). It is the 
user's  responsibility to assure the existences of COOR and CLS.   NEW 
must  not  be identical to any other existing model names.   Figure  3 
depicts the model structure.

    There exist three types of couplings : INTERNAL, EXT-INP, and OUT-
EXT.

    Associated  with COOR are three coupling lists :   int-coup,  ext-
inp,  and  out-ext, representing respectively INTERNAL,  EXT-INP,  and 
OUT-EXT.

    Similarly, the final three coupling lists for COOR are  fint-coup, 
fext-inp, and fout-ext.

    Besides,  the coupling lists for NEW are Nint-coup, Next-inp,  and 
Nout-ext.


                             5. Algorithm


STEP 1.  Handling INT-COUP

              FOR each e in INT-COUP
                  IF (e.source in GNAMES) & (e.target not in GNAMES)
                  THEN put C1 into NOUT-EXT &
                       put C2 into PINT-COUP  where
                       C1.source = e.source,
                       C1.target = NEW,
                       C1.out    = e.out,
                       C1.in     = NEW_OUT_PORT,
                       C2.source = NEW,
                       C2.target = e.target,
                       C2.out    = C1.in,
                   and C2.in     = e.in.


                  ELSE IF (e.source not in GNAMES) & (e.target in GNAMES)
                  THEN put C1 into NEXT-INP &
                       put C2 into PINT-COUP   where
                       C1.source = NEW,
                       C1.target = e.target,
                       C1.out    = NEW_IN_PORT,
                       C1.in     = e.in,
                       C2.source = e.source,
                       C2.target = NEW,
                       C2.out    = e.out,
                       C2.in     = C1.out.

                  ELSE IF (e.source in GNAMES) & (e.target in GNAMES)
                  THEN put e into NINT-COUP
                  ELSE put e into PINT-COUP.


STEP 2.  Dealing with EXT-INP.

              FOR each e in EXT-INP
                  IF (e.target not in GNAMES)
                  THEN put e into PEXT-INP
                  ELSE put C1 into PEXT-INP &
                       put C2 into NEXT-INP  where
                       C1.source = e.source,
                       C1.target = NEW,
                       C1.out    = e.out,
                       C1.in     = NEW_IN_PORT,
                       C2.source = NEW,
                       C2.target = e.target,
                       C2.out    = C1.in,
                       C2.in     = e.in.

STEP 3. Managing OUT-EXT.

              FOR each e in OUT-EXT
                  IF (e.source not in GNAMES)
                  THEN put e into POUT-EXT
                  ELSE put C1 into POUT-EXT &
                       put C2 into NOUT-EXT  where
                       C1.source = NEW,
                       C1.target = e.target,
                       C1.out    = NEW_OUT_PORT,
                       C1.in     = e.in,
                       C2.source = e.source,
                       C2.target = e.target,
                       C2.out    = e.out,
                       C2.in     = C1.out.


STEP 4.  Setup Composition Trees

    NEW contains all models named in GNAMES.

    COOR contains all original models except those in GNAMES.
    

STEP 5. Set up Influence Digraph

    Based  on  PINT-COUP and NINT-COUP, we can  build  the   influence 
digraphs.


STEP 6.  Set up Internal Couplings

    Based on PINT-COUP and NINT-COUP.


STEP 7.  Set up EXT-INP couplings

    Based on PEXT-INP and NEXT-INP.


STEP 8.  Set up OUT-EXT couplings

    Based on POUT-EXT and NOUT-EXT.


                            6. Conclusion


    The  proposed algorithm has been coded in SCHEME, tested in  DEVS-
SCHEME environment, and shown to be correct.

